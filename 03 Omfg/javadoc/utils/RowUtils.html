<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="de">
<head>
<!-- Generated by javadoc (1.8.0_65) on Tue Jun 12 08:03:56 CEST 2018 -->
<title>RowUtils</title>
<meta name="date" content="2018-06-12">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="RowUtils";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10,"i20":10,"i21":10,"i22":10,"i23":10,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":10,"i30":10,"i31":10,"i32":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/RowUtils.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../utils/RowSolvingUtil.html" title="interface in utils"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../index.html?utils/RowUtils.html" target="_top">Frames</a></li>
<li><a href="RowUtils.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">utils</div>
<h2 title="Class RowUtils" class="title">Class RowUtils</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>utils.RowUtils</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../utils/RowIsoUtil.html" title="interface in utils">RowIsoUtil</a>, <a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="typeNameLabel">RowUtils</span>
extends java.lang.Object
implements <a href="../utils/RowIsoUtil.html" title="interface in utils">RowIsoUtil</a>, <a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></pre>
<dl>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Christoph Teichmeister</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) java.util.LinkedList[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#allCandidateArray">allCandidateArray</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#arrayIndex">arrayIndex</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) java.util.List&lt;<a href="../data/Grid.html" title="class in data">Grid</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#changes">changes</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) <a href="../data/Grid.html" title="class in data">Grid</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#changesArray">changesArray</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#deleteCandidates">deleteCandidates</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) java.util.LinkedList[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#deleteCandidatesfromCell">deleteCandidatesfromCell</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#foundHiddenRow">foundHiddenRow</a></span></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>(package private) int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#foundNakedRow">foundNakedRow</a></span></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>(package private) boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#updateChangedSomething">updateChangedSomething</a></span></code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#RowUtils--">RowUtils</a></span>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#applyBlockInternRowPermutation-data.Grid-data.Cell-int:A-">applyBlockInternRowPermutation</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                              <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor,
                              int[]&nbsp;image)</code>
<div class="block">Wendet die durch den Bildvektor image beschriebene blockinterne Zeilenpermutation auf die Row an,
 deren Ankerzelle in anchor abzulesen ist.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#applyRowValuePermutation-data.Grid-data.Cell-int:A-">applyRowValuePermutation</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                        <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor,
                        int[]&nbsp;image)</code>
<div class="block">Wendet die durch den Bildvektor image beschriebene Wertpermutation auf die Einheit in grid an.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#checkBlock-int-int:A-data.Grid-data.Cell-">checkBlock</a></span>(int&nbsp;cellIndex,
          int[]&nbsp;candidateArray,
          <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
          <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Hilfsmethode zu updateAllCandidates.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#checkCol-int-int:A-data.Grid-">checkCol</a></span>(int&nbsp;cellIndex,
        int[]&nbsp;candidateArray,
        <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Hilfsmethode zu updateAllCandidates.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#checkRow-int:A-data.Grid-data.Cell-">checkRow</a></span>(int[]&nbsp;candidateArray,
        <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
        <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Hilfsmethode zu updateAllCandidates.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#fillCandidateArray--">fillCandidateArray</a></span>()</code>
<div class="block">Hilfsmethode um das CandidateArray, mit dem in der Methode updateAllCandidates gearbeitet wird, mit den Zahlen 1-9 aufzufuellen.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#getBlockInternRowPermutationImage-data.Grid-data.Grid-data.Cell-">getBlockInternRowPermutationImage</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid1,
                                 <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid2,
                                 <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Gibt den Blockbildvektor zurueck, der die Blockpermutation beschreibt,
   welche auf grid1 angewendet wurde, so dass grid2 entstanden ist.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../data/Cell.html" title="class in data">Cell</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#getRowMinimalHiddenPairCells-data.Grid-data.Cell-">getRowMinimalHiddenPairCells</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                            <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Gibt das minimale HiddenPair-Zellpaar der Einheit zurueck.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../data/Cell.html" title="class in data">Cell</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#getRowMinimalHiddenSingleCell-data.Grid-data.Cell-">getRowMinimalHiddenSingleCell</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                             <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Gibt die minimale HiddenSingle-Zelle der Einheit zurueck.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../data/Cell.html" title="class in data">Cell</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#getRowMinimalNakedPairCells-data.Grid-data.Cell-">getRowMinimalNakedPairCells</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                           <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Gibt das minimale NakedPair-Zellpaar der Einheit zurueck.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../data/Cell.html" title="class in data">Cell</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#getRowMinimalNakedSingleCell-data.Grid-data.Cell-">getRowMinimalNakedSingleCell</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                            <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Gibt die minimale NakedSingle-Zelle der Einheit zurueck.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#getRowValuePermutationImage-data.Grid-data.Grid-data.Cell-">getRowValuePermutationImage</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid1,
                           <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid2,
                           <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Gibt den Bildvektor der Wertpermutation wieder, welche die Einheit von grid1 in die Einheit von grid2 ueberfuehrt hat.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../data/Cell.html" title="class in data">Cell</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#getRowWhiteSpaces-data.Grid-data.Cell-">getRowWhiteSpaces</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                 <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Gibt aufsteigend sortiert alle Zellen der Einheit zurueck, welche eine -1 beinhalten.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#hasFullHouseRow-data.Grid-">hasFullHouseRow</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Entscheidet, ob in grid eine FullHouse-Row existiert;
  liefert den Wert true, falls ja, false sonst.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#isBlockInternRowPermutation-data.Grid-data.Grid-">isBlockInternRowPermutation</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid1,
                           <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid2)</code>
<div class="block">Entscheidet, ob grid2 aus grid1 entstanden ist,
  indem eine Blockpermutation vorgenommen wurde;
  falls ja, wird true zurueckgeliefert, sonst false.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#isFullHouseRow-data.Grid-data.Cell-">isFullHouseRow</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
              <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Entscheidet, ob die Einheit eine FullHouse-Einheit ist;
 liefert den Wert true, falls ja, false sonst.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#isRowValuePermutation-data.Grid-data.Grid-data.Cell-">isRowValuePermutation</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid1,
                     <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid2,
                     <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Entscheidet, ob die Einheit in grid2 durch eine Wertpermutation der Einheit in grid1 entstanden ist.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#isRowWithHiddenPairCells-data.Grid-data.Cell-">isRowWithHiddenPairCells</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                        <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Entscheidet, ob die Einheit ein HiddenPair-Zellpaar enthaelt.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#isRowWithHiddenSingleCell-data.Grid-data.Cell-">isRowWithHiddenSingleCell</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                         <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Entscheidet, ob die Einheit mindestens eine HiddenSingle-Zelle enthaelt.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#isRowWithNakedPairCells-data.Grid-data.Cell-">isRowWithNakedPairCells</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                       <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Entscheidet, ob die Einheit ein NakedPair-Zellpaar enthaelt;
 liefert den Wert true, falls ja, sonst false.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#isRowWithNakedSingleCell-data.Grid-data.Cell-">isRowWithNakedSingleCell</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                        <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Entscheidet, ob die Einheit mindestens eine
  NakedSingle-Zelle enthaelt.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#isValidRow-data.Grid-data.Cell-">isValidRow</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
          <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</code>
<div class="block">Entscheidet, ob in der Einheit eine zulaessige Belegung vorliegt;
        liefert den Wert true, falls ja, false sonst.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>java.util.List&lt;<a href="../data/Grid.html" title="class in data">Grid</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#solveRowBased-data.Grid-">solveRowBased</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Analysiert mittels Abruf vorher programmierter Methoden, ob ein Sudoku loesbar ist und befuellt, falls moeglich,
   die Zellen entsprechend.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#step1-data.Grid-">step1</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Erster Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku vollstaendig und zulaessig gefuellt ist.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#step2-data.Grid-">step2</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Zweiter Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku eine FullHouse-Einheit besitzt.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#step3-data.Grid-">step3</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Dritter Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku mindestens eine NakedSingle Zelle besitzt.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#step4-data.Grid-">step4</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Vierter Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku mindestens eine HiddenSingle Zelle besitzt.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#step5-data.Grid-">step5</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Fuenfter Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku ein NakedPair besitzt.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#step6-data.Grid-">step6</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Sechster Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku ein HiddenPair besitzt.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#updateAllCandidates-data.Grid-">updateAllCandidates</a></span>(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</code>
<div class="block">Durchlaeuft fuer jede Zelle des Grids, die moeglichen Kandidaten und speichert diese in die LinkedList allCandidateArray.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>java.util.LinkedList[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#updateBlock-data.Cell-data.Cell-int-int-java.util.LinkedList:A:A-data.Grid-java.util.List-">updateBlock</a></span>(<a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;a,
           <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;b,
           int&nbsp;cand1,
           int&nbsp;cand2,
           java.util.LinkedList[][]&nbsp;aca,
           <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
           java.util.List&nbsp;cellsToDeleteFrom)</code>
<div class="block">Hilfsmethode zu Schritt 5 und 6 der Solver Methode.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>java.util.LinkedList[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#updateCol-data.Cell-data.Cell-int-int-java.util.LinkedList:A:A-data.Grid-java.util.List-">updateCol</a></span>(<a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;a,
         <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;b,
         int&nbsp;cand1,
         int&nbsp;cand2,
         java.util.LinkedList[][]&nbsp;aca,
         <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
         java.util.List&nbsp;cellsToDeleteFrom)</code>
<div class="block">Hilfsmethode zu Schritt 5 und 6 der Solver Methode.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>java.util.LinkedList[][]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../utils/RowUtils.html#updateRow-data.Cell-data.Cell-int-int-java.util.LinkedList:A:A-data.Grid-java.util.List-">updateRow</a></span>(<a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;a,
         <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;b,
         int&nbsp;cand1,
         int&nbsp;cand2,
         java.util.LinkedList[][]&nbsp;aca,
         <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
         java.util.List&nbsp;cellsToDeleteFrom)</code>
<div class="block">Hilfsmethode zu Schritt 5 und 6 der Solver Methode.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="allCandidateArray">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>allCandidateArray</h4>
<pre>java.util.LinkedList[][] allCandidateArray</pre>
</li>
</ul>
<a name="updateChangedSomething">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateChangedSomething</h4>
<pre>boolean updateChangedSomething</pre>
</li>
</ul>
<a name="deleteCandidates">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteCandidates</h4>
<pre>boolean deleteCandidates</pre>
</li>
</ul>
<a name="deleteCandidatesfromCell">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deleteCandidatesfromCell</h4>
<pre>java.util.LinkedList[] deleteCandidatesfromCell</pre>
</li>
</ul>
<a name="foundNakedRow">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foundNakedRow</h4>
<pre>int[] foundNakedRow</pre>
</li>
</ul>
<a name="foundHiddenRow">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>foundHiddenRow</h4>
<pre>int[] foundHiddenRow</pre>
</li>
</ul>
<a name="changes">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>changes</h4>
<pre>java.util.List&lt;<a href="../data/Grid.html" title="class in data">Grid</a>&gt; changes</pre>
</li>
</ul>
<a name="changesArray">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>changesArray</h4>
<pre><a href="../data/Grid.html" title="class in data">Grid</a>[] changesArray</pre>
</li>
</ul>
<a name="arrayIndex">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>arrayIndex</h4>
<pre>int arrayIndex</pre>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="RowUtils--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>RowUtils</h4>
<pre>public&nbsp;RowUtils()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="isValidRow-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isValidRow</h4>
<pre>public&nbsp;boolean&nbsp;isValidRow(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                          <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Entscheidet, ob in der Einheit eine zulaessige Belegung vorliegt;
        liefert den Wert true, falls ja, false sonst.
        Die Einheit wird durch anchor eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#isValidRow-data.Grid-data.Cell-">isValidRow</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem geprueft werden soll, ob sich eine validRow befindet</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean ob die Row valid ist oder nicht</dd>
</dl>
</li>
</ul>
<a name="hasFullHouseRow-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasFullHouseRow</h4>
<pre>public&nbsp;boolean&nbsp;hasFullHouseRow(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Entscheidet, ob in grid eine FullHouse-Row existiert;
  liefert den Wert true, falls ja, false sonst.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#hasFullHouseRow-data.Grid-">hasFullHouseRow</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem geprueft werden soll, ob sich eine fullHouse Reihe befindet</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>answer boolean ob geprueftes Sudoku eine fullHouseRow besitzt oder nicht</dd>
</dl>
</li>
</ul>
<a name="isFullHouseRow-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isFullHouseRow</h4>
<pre>public&nbsp;boolean&nbsp;isFullHouseRow(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                              <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Entscheidet, ob die Einheit eine FullHouse-Einheit ist;
 liefert den Wert true, falls ja, false sonst.
 Die Einheit wird durch anchor eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#isFullHouseRow-data.Grid-data.Cell-">isFullHouseRow</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem geprueft werden soll, ob sich eine fullHouse befindet</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean ob die gepruefte Row eine fullHouseRow ist oder nicht</dd>
</dl>
</li>
</ul>
<a name="isRowWithNakedSingleCell-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRowWithNakedSingleCell</h4>
<pre>public&nbsp;boolean&nbsp;isRowWithNakedSingleCell(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                        <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Entscheidet, ob die Einheit mindestens eine
  NakedSingle-Zelle enthaelt.
  Die Einheit wird durch anchor eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#isRowWithNakedSingleCell-data.Grid-data.Cell-">isRowWithNakedSingleCell</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem geprueft werden soll, ob sich eine Row mit einer NakedSingleCell befindet</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>answer boolean ob die gepruefte Row eine NakedSingleCell hat oder nicht</dd>
</dl>
</li>
</ul>
<a name="getRowMinimalNakedSingleCell-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRowMinimalNakedSingleCell</h4>
<pre>public&nbsp;<a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;getRowMinimalNakedSingleCell(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                         <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Gibt die minimale NakedSingle-Zelle der Einheit zurueck.
 Die Einheit wird durch anchor eindeutig festgelegt.
 Betrachtet nur den Fall in dem die Einheit mindestens eine NakedSingle-Zelle enthaelt, andere Faelle werden nicht abgegriffen</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#getRowMinimalNakedSingleCell-data.Grid-data.Cell-">getRowMinimalNakedSingleCell</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem die Zelle ermittelt werden soll, die eine NakedSingleCell ist.</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>grid.getCell(anchor.getrIndex(), cIndex+1) Die Zelle, die eine NakedSingleCell ist. null falls keine solche existiert.</dd>
</dl>
</li>
</ul>
<a name="isRowWithHiddenSingleCell-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRowWithHiddenSingleCell</h4>
<pre>public&nbsp;boolean&nbsp;isRowWithHiddenSingleCell(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                         <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Entscheidet, ob die Einheit mindestens eine HiddenSingle-Zelle enthaelt.
  Die Einheit wird durch anchor eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#isRowWithHiddenSingleCell-data.Grid-data.Cell-">isRowWithHiddenSingleCell</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem ermittelt werden soll, ob eine Reihe eine HiddenSingle-Zelle enthaelt.</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean true, falls eine solche Zelle existiert, false wenn nicht</dd>
</dl>
</li>
</ul>
<a name="getRowMinimalHiddenSingleCell-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRowMinimalHiddenSingleCell</h4>
<pre>public&nbsp;<a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;getRowMinimalHiddenSingleCell(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                          <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Gibt die minimale HiddenSingle-Zelle der Einheit zurueck.
  Die Einheit wird durch anchor eindeutig festgelegt.
  Es wird nur der Fall betrachtet, in dem die Einheit mindestens eine HiddenSingle-Zelle enthaelt.
  Andere Faelle werden nicht abgefangen</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#getRowMinimalHiddenSingleCell-data.Grid-data.Cell-">getRowMinimalHiddenSingleCell</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem die Zelle ermittelt werden soll, die eine HiddenSingle-Zelle ist.</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>grid.getCell(45-lostRow, 45-lostCol) returnt die Zelle, die eine HiddenSingle-Zelle ist, null falls es keine solche gibt.</dd>
</dl>
</li>
</ul>
<a name="isRowWithHiddenPairCells-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRowWithHiddenPairCells</h4>
<pre>public&nbsp;boolean&nbsp;isRowWithHiddenPairCells(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                        <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Entscheidet, ob die Einheit ein HiddenPair-Zellpaar enthaelt.
  Die Einheit wird durch anchor eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#isRowWithHiddenPairCells-data.Grid-data.Cell-">isRowWithHiddenPairCells</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem die Zellen ermittelt werden sollen, die ein HiddenSingle-Paar bilden.</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean true, falls Pair existiert, false falls nicht.</dd>
</dl>
</li>
</ul>
<a name="getRowMinimalHiddenPairCells-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRowMinimalHiddenPairCells</h4>
<pre>public&nbsp;<a href="../data/Cell.html" title="class in data">Cell</a>[]&nbsp;getRowMinimalHiddenPairCells(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                           <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Gibt das minimale HiddenPair-Zellpaar der Einheit zurueck.
  Dabei sind die zwei in Cell[] gespeicherten Zellen aufsteigend sortiert. 
  Gibt es kein HiddenPair-Zellpaarin der Einheit, so ist Cell[] leer.
  Die Einheit wird durch anchor eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#getRowMinimalHiddenPairCells-data.Grid-data.Cell-">getRowMinimalHiddenPairCells</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem die Zellen ermittelt werden sollen, die ein HiddenSingle-Paar bilden.</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>answer Das Cell[] Array in dem beide HiddenPair Zellen gespeichert sind. Falls es keine gibt, so wird ein leeres Cell[] Array returnt.</dd>
</dl>
</li>
</ul>
<a name="isRowWithNakedPairCells-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRowWithNakedPairCells</h4>
<pre>public&nbsp;boolean&nbsp;isRowWithNakedPairCells(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                       <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Entscheidet, ob die Einheit ein NakedPair-Zellpaar enthaelt;
 liefert den Wert true, falls ja, sonst false.
 Die Einheit wird durch anchor eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#isRowWithNakedPairCells-data.Grid-data.Cell-">isRowWithNakedPairCells</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem ermittelt werden soll, ob ein NakedPair existiert..</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean true, falls ein solches Pair existiert. False falls nicht.</dd>
</dl>
</li>
</ul>
<a name="getRowMinimalNakedPairCells-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRowMinimalNakedPairCells</h4>
<pre>public&nbsp;<a href="../data/Cell.html" title="class in data">Cell</a>[]&nbsp;getRowMinimalNakedPairCells(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                          <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Gibt das minimale NakedPair-Zellpaar der Einheit zurueck.
  Dabei sind die zwei in Cell[] gespeicherten Zellen aufsteigend sortiert.
  Gibt es kein NakedPair-Zellpaarin der Einheit, so ist dementsprechend Cell[] leer.
  Die Einheit wird durch anchor eindeutig festgelegt</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#getRowMinimalNakedPairCells-data.Grid-data.Cell-">getRowMinimalNakedPairCells</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem die Zellen ermittelt werden sollen, die ein NakedPair bilden.</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher, die Row auf der geprueft wird, bestimmt wird</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>cells Cell[] Array in dem die NakedPair-Zellen stehen. Returnt leeres cells Array, falls es solche nicht gibt.</dd>
</dl>
</li>
</ul>
<a name="applyBlockInternRowPermutation-data.Grid-data.Cell-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyBlockInternRowPermutation</h4>
<pre>public&nbsp;void&nbsp;applyBlockInternRowPermutation(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                           <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor,
                                           int[]&nbsp;image)</pre>
<div class="block">Wendet die durch den Bildvektor image beschriebene blockinterne Zeilenpermutation auf die Row an,
 deren Ankerzelle in anchor abzulesen ist.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowIsoUtil.html#applyBlockInternRowPermutation-data.Grid-data.Cell-int:A-">applyBlockInternRowPermutation</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowIsoUtil.html" title="interface in utils">RowIsoUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku auf dem die Blockinterne Row Permutation stattfinden soll..</dd>
<dd><code>anchor</code> - Die Ankerzelle mittels welcher die "Anker Row" ermittelt wird, mit welcher die RowPermutation stattfinden soll.</dd>
<dd><code>image</code> - Bildvektor, der angibt, wie die Reihen permutiert werden. Die 1. Reihe bildet auf die erste Stelle der Vektors ab und so weiter.</dd>
</dl>
</li>
</ul>
<a name="isBlockInternRowPermutation-data.Grid-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isBlockInternRowPermutation</h4>
<pre>public&nbsp;boolean&nbsp;isBlockInternRowPermutation(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid1,
                                           <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid2)</pre>
<div class="block">Entscheidet, ob grid2 aus grid1 entstanden ist,
  indem eine Blockpermutation vorgenommen wurde;
  falls ja, wird true zurueckgeliefert, sonst false.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowIsoUtil.html#isBlockInternRowPermutation-data.Grid-data.Grid-">isBlockInternRowPermutation</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowIsoUtil.html" title="interface in utils">RowIsoUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid1</code> - Das Ausgangssudoku, welches herangezogen wird, um herauszufinden ob grid2 aus einer Blockpermuation daraus entstanden ist.</dd>
<dd><code>grid2</code> - Das veraenderte Sudoku, auf dem geprueft wird, ob es aus einer Blockpermuation des ersten Sudokus entstand.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean true falls grid2 durch eine BLockPermutation aus grid1 entstand. False falls dies nicht der Fall.</dd>
</dl>
</li>
</ul>
<a name="getBlockInternRowPermutationImage-data.Grid-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBlockInternRowPermutationImage</h4>
<pre>public&nbsp;int[]&nbsp;getBlockInternRowPermutationImage(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid1,
                                               <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid2,
                                               <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Gibt den Blockbildvektor zurueck, der die Blockpermutation beschreibt,
   welche auf grid1 angewendet wurde, so dass grid2 entstanden ist.
   Es wird nur der Fall betrachtet, in dem grid2 durch eine BlockPermuation von Grid1 entstand.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowIsoUtil.html#getBlockInternRowPermutationImage-data.Grid-data.Grid-data.Cell-">getBlockInternRowPermutationImage</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowIsoUtil.html" title="interface in utils">RowIsoUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid1</code> - Das Ausgangssudoku, welches herangezogen wird, um herauszufinden ob grid2 aus einer Blockpermuation daraus entstanden ist.</dd>
<dd><code>grid2</code> - Das veraenderte Sudoku, auf dem geprueft wird, ob es aus einer Blockpermuation des ersten Sudokus entstand.</dd>
<dd><code>anchor</code> - Ankerzelle auf der geprueft wird, ob die Rows aus grid2 durch eine Permutation der Rows aus grid1 entstanden ist.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>image Der Vektor durch den, grid2 aus grid1 entstanden ist.</dd>
</dl>
</li>
</ul>
<a name="applyRowValuePermutation-data.Grid-data.Cell-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>applyRowValuePermutation</h4>
<pre>public&nbsp;void&nbsp;applyRowValuePermutation(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                     <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor,
                                     int[]&nbsp;image)</pre>
<div class="block">Wendet die durch den Bildvektor image beschriebene Wertpermutation auf die Einheit in grid an.
  Die Einheit wird durch anchor eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowIsoUtil.html#applyRowValuePermutation-data.Grid-data.Cell-int:A-">applyRowValuePermutation</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowIsoUtil.html" title="interface in utils">RowIsoUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku, auf dem die Wertepermutation angewendet werden soll.</dd>
<dd><code>anchor</code> - Ankerzelle auf der die Wertepermutation stattfinden soll.</dd>
<dd><code>image</code> - Vektor, der beschreibt welche Zahl auf welche abbildet.</dd>
</dl>
</li>
</ul>
<a name="getRowValuePermutationImage-data.Grid-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRowValuePermutationImage</h4>
<pre>public&nbsp;int[]&nbsp;getRowValuePermutationImage(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid1,
                                         <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid2,
                                         <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Gibt den Bildvektor der Wertpermutation wieder, welche die Einheit von grid1 in die Einheit von grid2 ueberfuehrt hat.
 Die Einheit wird durch anchor eindeutig festgelegt.
 Dabei wird nur der Fall betrachtet, in dem grid2 durch eine Wertpermutation von grid1 entstanden ist.
 Andere Faelle werden mit der Methode nicht abgefangen.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowIsoUtil.html#getRowValuePermutationImage-data.Grid-data.Grid-data.Cell-">getRowValuePermutationImage</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowIsoUtil.html" title="interface in utils">RowIsoUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid1</code> - Das Sudoku, auf dem ermittelt werden soll, durch welchen Vektor grid2 entstanden ist.</dd>
<dd><code>grid1</code> - Das Sudoku, welches durch Wertepermutation aus grid1 entstanden ist.</dd>
<dd><code>anchor</code> - Ankerzelle auf der ermittelt wird, was der Vektor der Wertepermutation war.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>image Vektor, der beschreibt welche Zahl auf welche abbildet.</dd>
</dl>
</li>
</ul>
<a name="isRowValuePermutation-data.Grid-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRowValuePermutation</h4>
<pre>public&nbsp;boolean&nbsp;isRowValuePermutation(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid1,
                                     <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid2,
                                     <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Entscheidet, ob die Einheit in grid2 durch eine Wertpermutation der Einheit in grid1 entstanden ist.
  Falls ja, wird true geliefert, sonst false.
  Beide Einheiten sind durch anchor jeweils eindeutig festgelegt.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowIsoUtil.html#isRowValuePermutation-data.Grid-data.Grid-data.Cell-">isRowValuePermutation</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowIsoUtil.html" title="interface in utils">RowIsoUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid1</code> - Das Sudoku, auf dem ermittelt werden soll, ob grid2 durch eine WertePermutation aus grid1 entstanden ist.</dd>
<dd><code>grid1</code> - Das Sudoku, von dem ermittelt werden soll, ob es aus grid1 entstanden ist.</dd>
<dd><code>anchor</code> - Ankerzelle auf der ermittelt wird, ob grid2 aus grid1 entstanden ist</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean true, falls grid2 aus grid1 entstanden ist. False falls nicht.</dd>
</dl>
</li>
</ul>
<a name="getRowWhiteSpaces-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getRowWhiteSpaces</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../data/Cell.html" title="class in data">Cell</a>&gt;&nbsp;getRowWhiteSpaces(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                              <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Gibt aufsteigend sortiert alle Zellen der Einheit zurueck, welche eine -1 beinhalten.
   Die Einheit wird durch anchor eindeutig festgelegt.
   Enthaelt die Einheit keine leeren Zellen, so ist die Liste dementsprechend leer.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#getRowWhiteSpaces-data.Grid-data.Cell-">getRowWhiteSpaces</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku, auf dem die white Spaces ermittelt werden sollen.</dd>
<dd><code>anchor</code> - Ankerzelle auf der ermittelt wird, ob grid2 aus grid1 entstanden ist</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>List<Cell> List, die die Zellen die nicht belegt sind, zurueckgibt. Leer, falls es solche Zellen nicht gibt.</dd>
</dl>
</li>
</ul>
<a name="solveRowBased-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>solveRowBased</h4>
<pre>public&nbsp;java.util.List&lt;<a href="../data/Grid.html" title="class in data">Grid</a>&gt;&nbsp;solveRowBased(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Analysiert mittels Abruf vorher programmierter Methoden, ob ein Sudoku loesbar ist und befuellt, falls moeglich,
   die Zellen entsprechend. Gibt eine Liste der Grids zurueck, die nach jeder Zellenveraenderung entstanden sind.</div>
<dl>
<dt><span class="overrideSpecifyLabel">Specified by:</span></dt>
<dd><code><a href="../utils/RowSolvingUtil.html#solveRowBased-data.Grid-">solveRowBased</a></code>&nbsp;in interface&nbsp;<code><a href="../utils/RowSolvingUtil.html" title="interface in utils">RowSolvingUtil</a></code></dd>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku, auf dem die Methoden angewandt werden, um es zu loesen.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>List<Grid> List, die die Grids die nach jeder Zellenveraenderung entstanden sind, wiedergibt.</dd>
</dl>
</li>
</ul>
<a name="updateAllCandidates-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateAllCandidates</h4>
<pre>public&nbsp;void&nbsp;updateAllCandidates(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Durchlaeuft fuer jede Zelle des Grids, die moeglichen Kandidaten und speichert diese in die LinkedList allCandidateArray.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - Das Sudoku, dessen Zellen durchlaufen werden, dessen Kandidaten ermittelt werden sollen.</dd>
</dl>
</li>
</ul>
<a name="checkRow-int:A-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkRow</h4>
<pre>public&nbsp;int[]&nbsp;checkRow(int[]&nbsp;candidateArray,
                      <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                      <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Hilfsmethode zu updateAllCandidates. DUrchlaeuft die jeweilige Reihe der aktuell uebergebenen Zelle um fuer diese die Kandidaten zu ermitteln.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>candidateArray</code> - Ein Array auf dem von Stelle 0 bis 8, alle moeglichen Kandidaten von 1 bis 9 gespeichert sind.</dd>
<dd><code>grid</code> - Grid, dessen Zellen durchlaufen werden um ihre Kandidatenlisten zu erhalten.</dd>
<dd><code>anchor</code> - Zelle die aktuell ihre Kandidatenliste erhaelt.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>int[] candidateArray Ein Array auf dem, nach durchlaufen der Methode, alle in der Reihe auftretenden Zahlen, mit einer null ersetzt wurden.</dd>
</dl>
</li>
</ul>
<a name="checkCol-int-int:A-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkCol</h4>
<pre>public&nbsp;int[]&nbsp;checkCol(int&nbsp;cellIndex,
                      int[]&nbsp;candidateArray,
                      <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Hilfsmethode zu updateAllCandidates. Durchlaeuft die jeweilige Column der aktuell uebergebenen Zelle um fuer diese die Kandidaten zu ermitteln.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cellIndex</code> - der Index der Column, an dem sich die aktuell abgefragte Zelle befindet.</dd>
<dd><code>candidateArray</code> - Ein Array auf dem von Stelle 0 bis 8, alle moeglichen Kandidaten von 1 bis 9 gespeichert sind.</dd>
<dd><code>grid</code> - Grid, dessen Zellen durchlaufen werden um ihre Kandidatenlisten zu erhalten.</dd>
<dd><code>anchor</code> - Zelle die aktuell ihre Kandidatenliste erhaelt.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>int[] candidateArray Ein Array auf dem, nach durchlaufen der Methode, alle in der Column auftretenden Zahlen, mit einer null ersetzt wurden.</dd>
</dl>
</li>
</ul>
<a name="checkBlock-int-int:A-data.Grid-data.Cell-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkBlock</h4>
<pre>public&nbsp;int[]&nbsp;checkBlock(int&nbsp;cellIndex,
                        int[]&nbsp;candidateArray,
                        <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                        <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;anchor)</pre>
<div class="block">Hilfsmethode zu updateAllCandidates. Durchlaeuft den jeweiligen Block der aktuell uebergebenen Zelle um fuer diese die Kandidaten zu ermitteln.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cellIndex</code> - der Index der Column, an dem sich die aktuell abgefragte Zelle befindet.</dd>
<dd><code>candidateArray</code> - Ein Array auf dem von Stelle 0 bis 8, alle moeglichen Kandidaten von 1 bis 9 gespeichert sind.</dd>
<dd><code>grid</code> - Grid, dessen Zellen durchlaufen werden um ihre Kandidatenlisten zu erhalten.</dd>
<dd><code>anchor</code> - Zelle die aktuell ihre Kandidatenliste erhaelt.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>int[] candidateArray Ein Array auf dem, nach durchlaufen der Methode, alle in dem Block auftretenden Zahlen, mit einer null ersetzt wurden.</dd>
</dl>
</li>
</ul>
<a name="updateRow-data.Cell-data.Cell-int-int-java.util.LinkedList:A:A-data.Grid-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateRow</h4>
<pre>public&nbsp;java.util.LinkedList[][]&nbsp;updateRow(<a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;a,
                                          <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;b,
                                          int&nbsp;cand1,
                                          int&nbsp;cand2,
                                          java.util.LinkedList[][]&nbsp;aca,
                                          <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                          java.util.List&nbsp;cellsToDeleteFrom)</pre>
<div class="block">Hilfsmethode zu Schritt 5 und 6 der Solver Methode. Durchlaeuft die Rows der gefundenen HiddenPair/NakedPair Zellen und loescht die moeglichen Werte dieser aus den Kandidaten Listen der Zellen.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - "Erste" Zelle des Pairs.</dd>
<dd><code>b</code> - "Zweite" Zelle des Pairs.</dd>
<dd><code>cand1</code> - Erster Kandidat des Pairs.</dd>
<dd><code>cand2</code> - Zweiter Kandidat des Pairs.</dd>
<dd><code>aca</code> - allCandidateArray. Das Array in dem die Kandidatenlisten gespeichert sind und auf dem dementsprechend die Updates der Kandidatenlisten durchgefuehrt werden muessen.</dd>
<dd><code>grid</code> - Grid, dessen Zellen durchlaufen werden um ihre Kandidatenlisten zu erhalten.</dd>
<dd><code>cellsToDeleteFrom</code> - List, in der die Zellen, aus deren Kandidatenlisten die Kandidaten der Pairs geloescht wurden, speichert um diese bei zukuenftigen KandidatenUpdates nicht faelschlicherweise mit den Kandidaten der Pairs zu belegen.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>aca allCandidateArray. Gibt die geaenderte Kandidatenliste zurueck.</dd>
</dl>
</li>
</ul>
<a name="updateCol-data.Cell-data.Cell-int-int-java.util.LinkedList:A:A-data.Grid-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateCol</h4>
<pre>public&nbsp;java.util.LinkedList[][]&nbsp;updateCol(<a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;a,
                                          <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;b,
                                          int&nbsp;cand1,
                                          int&nbsp;cand2,
                                          java.util.LinkedList[][]&nbsp;aca,
                                          <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                          java.util.List&nbsp;cellsToDeleteFrom)</pre>
<div class="block">Hilfsmethode zu Schritt 5 und 6 der Solver Methode. Durchlaeuft die Columns der gefundenen HiddenPair/NakedPair Zellen und loescht die moeglichen Werte dieser aus den Kandidaten Listen der Zellen.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - "Erste" Zelle des Pairs.</dd>
<dd><code>b</code> - "Zweite" Zelle des Pairs.</dd>
<dd><code>cand1</code> - Erster Kandidat des Pairs.</dd>
<dd><code>cand2</code> - Zweiter Kandidat des Pairs.</dd>
<dd><code>aca</code> - allCandidateArray. Das Array in dem die Kandidatenlisten gespeichert sind und auf dem dementsprechend die Updates der Kandidatenlisten durchgefuehrt werden muessen.</dd>
<dd><code>grid</code> - Grid, dessen Zellen durchlaufen werden um ihre Kandidatenlisten zu erhalten.</dd>
<dd><code>cellsToDeleteFrom</code> - List, in der die Zellen, aus deren Kandidatenlisten die Kandidaten der Pairs geloescht wurden, speichert um diese bei zukuenftigen KandidatenUpdates nicht faelschlicherweise mit den Kandidaten der Pairs zu belegen.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>aca allCandidateArray. Gibt die geaenderte Kandidatenliste zurueck.</dd>
</dl>
</li>
</ul>
<a name="updateBlock-data.Cell-data.Cell-int-int-java.util.LinkedList:A:A-data.Grid-java.util.List-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateBlock</h4>
<pre>public&nbsp;java.util.LinkedList[][]&nbsp;updateBlock(<a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;a,
                                            <a href="../data/Cell.html" title="class in data">Cell</a>&nbsp;b,
                                            int&nbsp;cand1,
                                            int&nbsp;cand2,
                                            java.util.LinkedList[][]&nbsp;aca,
                                            <a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid,
                                            java.util.List&nbsp;cellsToDeleteFrom)</pre>
<div class="block">Hilfsmethode zu Schritt 5 und 6 der Solver Methode. Durchlaeuft die Bloecke der gefundenen HiddenPair/NakedPair Zellen und loescht die moeglichen Werte dieser aus den Kandidaten Listen der Zellen.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a</code> - "Erste" Zelle des Pairs.</dd>
<dd><code>b</code> - "Zweite" Zelle des Pairs.</dd>
<dd><code>cand1</code> - Erster Kandidat des Pairs.</dd>
<dd><code>cand2</code> - Zweiter Kandidat des Pairs.</dd>
<dd><code>aca</code> - allCandidateArray. Das Array in dem die Kandidatenlisten gespeichert sind und auf dem dementsprechend die Updates der Kandidatenlisten durchgefuehrt werden muessen.</dd>
<dd><code>grid</code> - Grid, dessen Zellen durchlaufen werden um ihre Kandidatenlisten zu erhalten.</dd>
<dd><code>cellsToDeleteFrom</code> - List, in der die Zellen, aus deren Kandidatenlisten die Kandidaten der Pairs geloescht wurden, speichert um diese bei zukuenftigen KandidatenUpdates nicht faelschlicherweise mit den Kandidaten der Pairs zu belegen.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>aca allCandidateArray. Gibt die geaenderte Kandidatenliste zurueck.</dd>
</dl>
</li>
</ul>
<a name="fillCandidateArray--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillCandidateArray</h4>
<pre>public&nbsp;int[]&nbsp;fillCandidateArray()</pre>
<div class="block">Hilfsmethode um das CandidateArray, mit dem in der Methode updateAllCandidates gearbeitet wird, mit den Zahlen 1-9 aufzufuellen.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a Das gefuellte CandidateArray</dd>
</dl>
</li>
</ul>
<a name="step1-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>step1</h4>
<pre>public&nbsp;boolean&nbsp;step1(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Erster Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku vollstaendig und zulaessig gefuellt ist.
   Returnt false, falls dem so ist. True falls es nicht vollstaendig oder zulaessig belegt ist.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - grid auf dem Reihen auf Zulaessigkeit geprueft werden.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>answer true, falls nicht vollstaendig oder zulaessig. false falls schon.</dd>
</dl>
</li>
</ul>
<a name="step2-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>step2</h4>
<pre>public&nbsp;boolean&nbsp;step2(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Zweiter Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku eine FullHouse-Einheit besitzt. 
   Falls es eine solche besitzt, fuellt es die Zelle dieser mit ihrem einzig moeglichen Wert.
   Returnt true, falls dies geschehen ist. Returnt false, falls es keine solche Zelle bzw Einheit gibt.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - grid auf dem die Reihen nach einer FullHouse Zelle ueberprueft werden.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>answer true, falls eine FullHouse Zelle gefunden wurde, false falls nicht.</dd>
</dl>
</li>
</ul>
<a name="step3-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>step3</h4>
<pre>public&nbsp;boolean&nbsp;step3(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Dritter Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku mindestens eine NakedSingle Zelle besitzt. 
   Falls es eine solche besitzt, fuellt es die Zelle dieser mit ihrem einzig moeglichen Wert.
   Returnt true, falls dies geschehen ist. Returnt false, falls es keine solche Zelle bzw Einheit gibt.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - grid auf dem die Reihen nach einer NakedSingle Zelle ueberprueft werden.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>answer true, falls eine NakedSingle Zelle gefunden wurde, false falls nicht.</dd>
</dl>
</li>
</ul>
<a name="step4-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>step4</h4>
<pre>public&nbsp;boolean&nbsp;step4(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Vierter Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku mindestens eine HiddenSingle Zelle besitzt. 
   Falls es eine solche besitzt, fuellt es die Zelle dieser mit ihrem einzig moeglichen Wert.
   Returnt true, falls dies geschehen ist. Returnt false, falls es keine solche Zelle bzw Einheit gibt.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - grid auf dem die Reihen nach einer HiddenSingle Zelle ueberprueft werden.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>answer true, falls eine HiddenSingle Zelle gefunden wurde, false falls nicht.</dd>
</dl>
</li>
</ul>
<a name="step5-data.Grid-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>step5</h4>
<pre>public&nbsp;boolean&nbsp;step5(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Fuenfter Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku ein NakedPair besitzt.
   Falls es ein solches besitzt, werden die jeweiligen Kandidaten aus allen, von diesen PairZellen, betroffenen Zellen-Kandidatenlisten geloescht.
   Falls dieses Vorgehen in mindestens einer Kandidatenlist etwas geaendert hat, wird true returnt. Falls nicht, false.
   Die Kandidaten werden dabei nicht aus den PairZellen-Kandidatenlisten geloescht.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - grid auf dem ein NakedPair gesucht wird.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean true, falls das KAndidatenlisten Update in mindestens einer Kandidatenliste etwas geaendert hat. False falls nicht.</dd>
</dl>
</li>
</ul>
<a name="step6-data.Grid-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>step6</h4>
<pre>public&nbsp;boolean&nbsp;step6(<a href="../data/Grid.html" title="class in data">Grid</a>&nbsp;grid)</pre>
<div class="block">Sechster Schritt der Solver Methode, in dem ermittelt wird ob das Sudoku ein HiddenPair besitzt.
   Falls es ein solches besitzt, werden die jeweiligen Kandidaten aus allen, von diesen PairZellen, betroffenen Zellen-Kandidatenlisten geloescht.
   Falls dieses Vorgehen in mindestens einer Kandidatenlist etwas geaendert hat, wird true returnt. Falls nicht, false.
   Die Kandidaten werden dabei nicht aus den PairZellen-Kandidatenlisten geloescht.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>grid</code> - grid auf dem ein HiddenPair gesucht wird.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>boolean true, falls das Kandidatenlisten Update in mindestens einer Kandidatenliste etwas geaendert hat. False falls nicht.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/RowUtils.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-files/index-1.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../utils/RowSolvingUtil.html" title="interface in utils"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li>Next&nbsp;Class</li>
</ul>
<ul class="navList">
<li><a href="../index.html?utils/RowUtils.html" target="_top">Frames</a></li>
<li><a href="RowUtils.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
